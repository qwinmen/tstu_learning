/*==========================================*/
/* Compressor / DeCompressor (32.04.2009)   */
/*==========================================*/
/* Бебякин Виктор Александрович             */
/* mail: prog.81@mail.ru                    */
/* icq : 487-975-512                        */
/*==========================================*/

/*================================================================*/
/* описание алгоритма компрессии                                  */
/*================================================================*/
/* <RLE>                                                          */
/*     если последовательность одинаковых символов больше 2-х, то */
/*     записываем количество символов и повторющийся символ.      */
/* <DIGITAL>                                                      */
/*     записываем чимвол числа в двоичном виде.                   */
/* <NoCompressed>                                                 */
/*     записываем идентификатор начала не сжатых символов         */
/*     записываем количество символов и сами символы              */
/*================================================================*/

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ctype.h>

/* идентификатор части байта */
typedef enum bytelevel
{
	LO = 0,		/* нижняя  */
	HI = !LO,	/* верхняя */
}ByteLevel, BYTELEVEL, *LPBYTELEVEL;

/* количество бит необходимых для кодирования символа */
enum
{
	BIT_DIGIT = 4,
	BIT_RLE   = 8,
	BIT_ALPHA = 12,
};

enum 
{
	ID_RLE		= 0xA, /* идентификатор алгоритма RLE */
	ID_ADD_CNT	= 0xF, /* идентификатор добавления счетчика */
};

/*---------------------------------------------*/
/* Подсчет одинаковых символов в начале строки */
/*---------------------------------------------*/
/* A         - строка символов                 */
/*---------------------------------------------*/
/* Результат - количество одинаковых символов  */
/*             вначале строки                  */
/*---------------------------------------------*/
int CountCharDuplicates(char* A)
{
	int res = 1;
	char c = *A;
	A++;
	while (*A != 0 && *A == c)
	{
		res++;
		A++;
	}
	return res;
}

/*---------------------------------------------*/
/* Длина не сжимаемой последовательности       */
/*---------------------------------------------*/
/* A         - строка символов                 */
/*---------------------------------------------*/
/* Результат - количество символов             */
/*---------------------------------------------*/
int LenNoCompressed(char* A)
{
	int res = 0;
	while (*A != 0 && !isdigit(*A) && (CountCharDuplicates(A) < 3))
	{
		res++;
		A++;
	}
	return res;
}

/*---------------------------------------------*/
/* запись от 4 до 16 бит                       */
/*---------------------------------------------*/
/* buff      - буфер для записи                */
/* bl        - младшая или старша часть байта  */
/* value     - записываемое значение           */
/* cnt       - количаство полубайт для записи  */
/*---------------------------------------------*/
/* Результат - текущая часть байта (LO/HI)     */
/*---------------------------------------------*/
BYTELEVEL BuffWrite4bit(char** buff, BYTELEVEL bl, long value, int cnt)
{
	for (; cnt > 0; cnt--)
	{
		if (bl == LO)
		{
			/* записываем значение младшей части в младшую */
			**buff = value & 0xF;
		}
		else
		{
			/* записываем значение младшей части в старшую */
			**buff = **buff | ((value & 0xF) << 4);
			(*buff)++;
		}
			
		bl = !bl;
		/* делим на 16 или сдвигаем на 4 бита влево */
		value = value >> 4;
	}
	
	return bl;
}

/*---------------------------------------------*/
/* чтение от 4 до 16 бит                       */
/*---------------------------------------------*/
/* buff      - буфер чения                     */
/* bl        - младшая или старша часть байта  */
/* value     - презультат чтения               */
/* cnt       - количаство полубайт для чтения  */
/*---------------------------------------------*/
/* Результат - текущая часть байта (LO/HI)     */
/*---------------------------------------------*/
BYTELEVEL BuffRead4bit(char** buff, BYTELEVEL bl, long* value, int cnt)
{
	int i;
	*value = 0;
	for (i = 0; i < cnt; i++)
	{
		if (bl == LO)
		{
			/* получаем значение младшей части байта (**buff & 0xF), */
			/* сдвигаем в право на (i << 2) бит, */
			/* вставлем в (*value) */
			*value = *value | ((**buff & 0xF) << (i << 2));
		}
		else
		{
			/* получаем значение старшей части байта (**buff & 0xF0), */
			/* сдвигаем в право на (i << 2) бит, */
			/* вставлем в (*value) */
			*value = *value | (((**buff & 0xF0) >> 4) << (i << 2));
			(*buff)++;
		}
		bl = !bl;
	}

	return bl;
}

/*---------------------------------------*/
/* Размер сжатых данных                  */
/*---------------------------------------*/
/* In        - сжимаема строка           */
/*---------------------------------------*/
/* Результат - размер упакованных данных */
/*---------------------------------------*/
int CompressedBuffSize(char* In)
{
	int bits = 0; /* количество бит */
	int cnt;
	while (*In)
	{
		cnt = CountCharDuplicates(In);
		if (cnt > 18) cnt = 18;
		if (cnt > 2) /* кодируем алгоритмом RLE (количество, значение) */
		{
			In = In + cnt;
			bits += BIT_RLE + 8;
		}
		else
		if (isdigit(*In))
		{
			bits += BIT_DIGIT;
			In++;
		}
		else
		{			
			/* получаем количество символов */
			cnt = LenNoCompressed(In);
			if (cnt > 18) cnt = 18;
			if (cnt > 4)
			{
				bits += 8;
			}
			else
			{
				bits += 4;
			}
			
			bits += cnt << 3;
			In += cnt;
		}
	}	

	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}

/*------------------------------------------*/
/* кодирование строки                       */
/*------------------------------------------*/
/* In        - строка символов              */
/* Out       - буфер результата             */
/*------------------------------------------*/
/* Результат - размер закодированной строки */
/*------------------------------------------*/
int Compressor(char* In, char* Out)
{
	BYTELEVEL bl = LO;
	int bits = 0;
	int cnt;
	while (*In)
	{
		cnt = CountCharDuplicates(In);
		if (cnt > 18) cnt = 18;
		if (cnt > 2) /* кодируем алгоритмом RLE (количество, значение) */
		{
			bl = BuffWrite4bit(&Out, bl, ID_RLE, 1); /* идентификатор алгоритма */
			bl = BuffWrite4bit(&Out, bl, cnt-3, 1);  /* количество символов    */
			bl = BuffWrite4bit(&Out, bl, *In, 2);    /* повторяющийся символ  */
			In = In + cnt;
			bits += BIT_RLE + 8;
		}
		else
		if (isdigit(*In))
		{
			/* кодируем символ числа (0..9) */
			
			bits += BIT_DIGIT;
			bl = BuffWrite4bit(&Out, bl, *In - '0', 1);
			In++;
		}
		else
		{
			/* пропускаем символы не поддающиеся компрессии */
			
			cnt = LenNoCompressed(In);
			if (cnt > 18) cnt = 18;
			if (cnt > 4) /* добавляем счетчик */
			{
				bl = BuffWrite4bit(&Out, bl, ID_ADD_CNT, 1);
				bl = BuffWrite4bit(&Out, bl, cnt - 5, 1); /* количество */
				bits += 8;
			}
			else
			{
				bl = BuffWrite4bit(&Out, bl, cnt + ID_RLE, 1);
				bits += 4;
			}
			
			bits += cnt << 3;
			
			/* копируем символы */
			for ( ; cnt > 0; cnt--)
			{
				bl = BuffWrite4bit(&Out, bl, *In, 2);
				In++;				
			}
		}
	}	

	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}

/*------------------------------------------*/
/* декодирование строки                     */
/*------------------------------------------*/
/* In        - закодированная строка        */
/* InSize    - размер входной строки        */
/* Out       - буфер результата             */
/*------------------------------------------*/
/* Результат - размер декодированной строки */
/*------------------------------------------*/
int DeCompressor(char* In, char* Out, int OutSize)
{
	BYTELEVEL bl = LO;
	int bits = 0;
	long ch;
	int cnt;
	
	for ( ;OutSize > 0; OutSize--)
	{
		/* читаем идентификатор */
		bl = BuffRead4bit(&In, bl, &ch, 1);

		if (ch == ID_RLE)
		{
			bl = BuffRead4bit(&In, bl, &ch, 1); cnt = ch;
			bl = BuffRead4bit(&In, bl, &ch, 2);
			cnt += 3;
			for ( ; cnt > 0; cnt--)
			{
				*Out = (char)ch;
				Out++;
				bits += BIT_ALPHA;
			}
		}
		else
		if (ch > ID_RLE)
		{
			/* востанавливаем символы без сжатия */
			
			/* если есть счетчик, то*/
			if (ch == ID_ADD_CNT)
			{
				bl = BuffRead4bit(&In, bl, &ch, 1);
				cnt = ch + 5; /* реальное число символов */
			}
			else /* получаем количество из идентификатора */
				cnt = ch - ID_RLE;
			
			for ( ; cnt > 0; cnt--)
			{
				bl = BuffRead4bit(&In, bl, &ch, 2);
				*Out = (char)ch;
				Out++;
				bits += BIT_ALPHA;
			}
		}
		else
		{
			/* декодируем символ числа */
			*Out = (ch & 0x0F) + '0';
			bits += BIT_DIGIT;
			Out++;
		}
		
	}	

	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}


void separator(char c, int Color)
{
	int i;
	textcolor(Color);
	for (i = 0; i < 80; i++)
		putch(c);
}

void text_out(char* A, int Color)
{
	textcolor(Color);
	while (*A != 0)
	{
		putch(*A);
		A++;
	}
}

/*=======================================================*/
void main()
{
	char a[1024];	/* входные данные */
	char* b = 0;	/* сжатая строка  */
	int size_in;	/* размер исходной строки */
	int size_out;	/* размер выходной строки */
	
	do
	{
		clrscr();
		separator('=', GREEN);
		text_out(" \"String Compressor\"  ", LIGHTRED);
		text_out("Copyright By (C) U81 [mail:prog.81@mail.ru] (23.04.2009)", LIGHTGREEN);
		printf("\n");
		separator('=', GREEN);
		
		printf("\nInput text\n\t\t");
		gets(a);
		
		size_in		= strlen(a);
		size_out	= CompressedBuffSize(a)+1;
		/* выделяем память для сжатой строки */
		b = (char*)malloc(size_out)+1;
		/* сжимаем строку */
		Compressor(a, b);
		b[size_out+1] = 0; /* конец строки */
		/* выводим сжатую строку */
		printf("Str Pack:\n\t\t%s\n", b);
	
		/* очищаем исходную строку */
		memset(a, 0, size_in+1);
		/* разжимаем строку и помещаем результат в исходную строку */
		DeCompressor(b, a, size_in);
		a[size_in] = 0; /* конец строки */
		/* выводим результат декомпрессии */
		printf("Str UnPack:\n\t\t%s", a);
		/* освобождаем память выделенную для результата компрессии */
		free(b);

		/* выводим компрессию в процентах */
		printf("\n\ncompressed %.2f\%\n", ((double)(size_out-1) / (size_in)) * 100 );
		
		gotoxy(1,20);
		separator('-', RED);
		gotoxy(5,22);
		text_out("q - exit, press any key to Retry", YELLOW);
		
		textcolor(LIGHTGRAY);
	} while(getch() != 'q');
}



