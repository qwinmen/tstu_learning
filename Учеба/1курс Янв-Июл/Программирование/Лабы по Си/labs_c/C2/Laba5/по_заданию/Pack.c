#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <ctype.h>


/* булеевый тип */
typedef enum bool
{
	FALSE = 0,
	TRUE = !FALSE,
}Bool, BOOL, *LPBOOL;

typedef enum bytelevel
{
	LO = 0,
	HI = !LO,
}ByteLevel, BYTELEVEL, *LPBYTELEVEL;

/* количество бит необходимых для кодирования символа */
enum
{
	BIT_DIGIT = 4,
	BIT_ALPHA = 12,
};

/*---------------------------------------------*/
/* Подсчет одинаковых символов в начале строки */
/*---------------------------------------------*/
/* A         - строка символов                 */
/*---------------------------------------------*/
/* Результат - количество одинаковых символов  */
/*             вначале строки                  */
/*---------------------------------------------*/
int CountCharDuplicates(char* A)
{
	int res = 0;
	char c = *A;
	while (*A != 0 && *A == c) res++;
	return res;
}

/*---------------------------------------------*/
/* Подсчет числовых символов (0..9)            */
/*---------------------------------------------*/
/* A         - строка символов                 */
/*---------------------------------------------*/
/* Результат - количество числовых символов    */
/*             вначале строки                  */
/*---------------------------------------------*/
int CountCharDigit(char* A)
{
	int res = 0;
	while (*A != 0 && isdigit(*A)) res++;
	return res;
}

/*------------------------------------------*/
/* Подсчет места для закодированной строки  */
/*------------------------------------------*/
/* A         - строка символов              */
/*------------------------------------------*/
/* Результат - размер закодированной строки */
/*------------------------------------------*/
int CoderByteCount(char* A)
{
	int bits = 0; /* счетчик бит */
	
	/* пока не дошли до конца строки */
	while (*A)
	{
		/* считаем количество бит */
		
		/* если символ числовой, то */
		if (isdigit(*A))
		{
			bits += BIT_DIGIT;
		}
		else
		{
			/* любой символ кроме числа */
			bits += BIT_ALPHA;
		}
		A++;
	}
	
	/* переводим биты в байты */
	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}

/*---------------------------------------------*/
/* запись от 4 до 16 бит                       */
/*---------------------------------------------*/
/* buff      - буфер для записи                */
/* bl        - младшая или старша часть байта  */
/* value     - записываемое значение           */
/* cnt       - количаство полубайт для записи  */
/*---------------------------------------------*/
/* Результат - текущая часть байта (LO/HI)     */
/*---------------------------------------------*/
BYTELEVEL BuffWrite4bit(char** buff, BYTELEVEL bl, long value, int cnt)
{
	for (; cnt > 0; cnt--)
	{
		if (bl == LO)
		{
			**buff = **buff | (value & 0xF);
		}
		else
		{
			**buff = **buff | ((value & 0xF) << 4);
			(*buff)++;
		}
			
		bl = !bl;
		value = value >> 4;
	}
	
	return bl;
}

/*---------------------------------------------*/
/* запись от 4 до 16 бит                       */
/*---------------------------------------------*/
/* buff      - буфер чения                     */
/* bl        - младшая или старша часть байта  */
/* value     - презультат чтения               */
/* cnt       - количаство полубайт для чтения  */
/*---------------------------------------------*/
/* Результат - текущая часть байта (LO/HI)     */
/*---------------------------------------------*/
BYTELEVEL BuffRead4bit(char** buff, BYTELEVEL bl, long* value, int cnt)
{
	int i;
	*value = 0;
	for (i = 0; i < cnt; i++)
	{
		if (bl == LO)
		{
			*value = *value | ((**buff & 0xF) << (i * 4));
		}
		else
		{
			*value = *value | (((**buff & 0xF0) >> 4) << (i * 4));
			(*buff)++;
		}
		bl = !bl;
	}

	return bl;
}

/*------------------------------------------*/
/* кодирование строки                       */
/*------------------------------------------*/
/* In        - строка символов              */
/* Out       - буфер результата             */
/*------------------------------------------*/
/* Результат - размер закодированной строки */
/*------------------------------------------*/
int Coder(char* In, char* Out)
{
	BYTELEVEL bl = LO;
	int bits = 0;
	while (*In)
	{
		if (isdigit(*In))
		{
			bits += BIT_DIGIT;
			bl = BuffWrite4bit(&Out, bl, *In - '0', 1);
		}
		else
		{
			bits += BIT_ALPHA;
			bl = BuffWrite4bit(&Out, bl, 0xF, 1);
			bl = BuffWrite4bit(&Out, bl, *In, 2);
		}
		In++;
	}
	Out++;
	*Out = 0;
	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}

/*------------------------------------------*/
/* декодирование строки                     */
/*------------------------------------------*/
/* In        - закодированная строка        */
/* InSize    - размер входной строки        */
/* Out       - буфер результата             */
/*------------------------------------------*/
/* Результат - размер декодированной строки */
/*------------------------------------------*/
int DeCoder(char* In, int InSize, char* Out)
{
	BYTELEVEL bl = LO;
	int bits = 0;
	long ch;
	
	for ( ;InSize > 0; InSize--)
	{
		bl = BuffRead4bit(&In, bl, &ch, 1);
		if (ch == 0xF)
		{
			bl = BuffRead4bit(&In, bl, &ch, 2);
			*Out = (char)ch;
			bits += BIT_ALPHA;
		}
		else
		{
			*Out = (ch & 0x0F) + '0';
			bits += BIT_DIGIT;
		}
		Out++;
	}	
	*Out = 0;
	return bits - ((bits >> 3) << 3) ? (bits >> 3)+1 : (bits >> 3);
}


/*=======================================================*/
void main()
{
	char* a = "ABC123fdhg564";
	char* b;
	int size_in;
	int size_out;
		
	size_in		= strlen(a);
	size_out	= CoderByteCount(a);
	b = (char*)malloc(size_out)+1;
	memset(b, 0, size_out+1);
	
	printf("Coder : %s\n", a);
	printf("Size = %d\n", Coder(a, b));
	printf("Result: %s\n\n", b);
	
	memset(a, 0, size_in);
	printf("Decode size = %d\n", DeCoder(b, size_in, a));
	printf("Decoder : %s", a);
	
	free(b);

	getch();
}



