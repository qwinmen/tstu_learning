int search_delete(Node *root,int d){
 Node *pv=root, *next, *prev;
 bool found =false;
 while ((pv)&&(pv->d!=d)){
     prev=pv;
  if (d<pv->d){
   pv=pv->left;
  }
  else pv=pv->right;
  if (pv->d==d) found=true;
  cout<<"pr->d="<<prev->d<<" ";
     cout<<"pv->d="<<pv->d<<" ";
 }
 next=pv;
 if (found){
     //если нет левого или правого сына, то просто удаляем
     if ((pv->left==0)&&(pv->right!=0)){
         if (prev->left->d==pv->d) prev->left=pv->right;
            else if (prev->right->d==pv->d) prev->right=pv->right;
         return 1;
         }
        else if ((pv->left!=0)&&(pv->right==0)){
            if (prev->left->d==pv->d) prev->left=pv->left;
            else if (prev->right->d==pv->d) prev->right=pv->left;
         return 1;
         }
        else if ((pv->left==0)&&(pv->right==0)){
            if (prev->left->d==pv->d) prev->left=NULL;
            else if (prev->right->d==pv->d) prev->right=NULL;
            return 1;
         }
        //если есть оба сына - начинается взрыв мозга
        //сначала надо найти минимальный элемент в максимальной ветке
        pv=pv->right;
     while (pv->left!=0){
         pv=pv->left;
         }
        //теперь надо проверить, есть ли у этого элемента правый сын
        //если есть - мы ставим его на место родителя
        if (pv->right!=0){
            int temp=pv->d;
            search_delete(root,pv->d);
            next->d=temp;
            return 1;
            }
        else if (pv->right==0){
            //если сына нет, то мы переносим минимальный элемент на
            //место заменяемого, ищем его предка и удаляем элемент
            int temp=pv->d;
            search_delete(root,pv->d);
            next->d=temp;
            return 1;
            }
     }

    return 0;
}